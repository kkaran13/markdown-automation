name: Scan and Push Environment Variables Report

on:
  workflow_dispatch:
    inputs:
      branch:
        description: "Branch name to scan for environment variables"
        required: true
        default: "dev"   # default branch if none entered

jobs:
  scan-and-push:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout current repo
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.x"

      - name: Install dependencies
        run: pip install requests

      - name: Run Environment Variable Scanner and Publisher
        env:
          GITHUB_TOKEN: ${{ secrets.PERSONAL_TOKEN }}
          TARGET_USER_OR_ORG: kkaran13           # change to your username/org
          IS_ORG: "false"                        # set "true" for org
          TARGET_BRANCH: ${{ github.event.inputs.branch }}
        run: |
          python <<'EOF'
          import os, re, base64, requests, logging
          from pathlib import Path

          logging.basicConfig(level=logging.INFO, format="%(levelname)s: %(message)s")

          token = os.getenv("GITHUB_TOKEN")
          target = os.getenv("TARGET_USER_OR_ORG")
          is_org = os.getenv("IS_ORG", "false").lower() == "true"
          target_branch = os.getenv("TARGET_BRANCH", "dev")
          api = "https://api.github.com"

          headers = {
              "Authorization": f"Bearer {token}",
              "Accept": "application/vnd.github.v3+json"
          }

          def fetch_repos():
              repos = []
              page = 1
              while True:
                  url = f"{api}/orgs/{target}/repos?per_page=100&page={page}" if is_org else f"{api}/user/repos?per_page=100&page={page}"
                  r = requests.get(url, headers=headers)
                  if r.status_code != 200:
                      logging.error(f"Failed to fetch repos (HTTP {r.status_code}): {r.text}")
                      break
                  data = r.json()
                  if not data:
                      break
                  repos.extend([repo["name"] for repo in data])
                  page += 1
              return repos

          def get_branches(repo):
              r = requests.get(f"{api}/repos/{target}/{repo}/branches", headers=headers)
              if r.status_code != 200:
                  logging.warning(f"Failed to fetch branches for {repo}: {r.status_code}")
                  return []
              return [b["name"] for b in r.json()]

          def get_repo_files(repo, branch):
              files = []
              def walk(path=""):
                  url = f"{api}/repos/{target}/{repo}/contents/{path}?ref={branch}"
                  r = requests.get(url, headers=headers)
                  if r.status_code != 200:
                      return
                  for item in r.json():
                      if item["type"] == "file":
                          files.append(item["path"])
                      elif item["type"] == "dir":
                          walk(item["path"])
              walk()
              return files

          def download_file(repo, branch, path):
              url = f"{api}/repos/{target}/{repo}/contents/{path}?ref={branch}"
              r = requests.get(url, headers=headers)
              if r.status_code == 200:
                  return base64.b64decode(r.json().get("content", "").encode()).decode(errors="ignore")
              return ""

          def find_env_vars(content):
              patterns = [
                  r"os\.environ\.get\(['\"]([^'\"]+)['\"]\)",
                  r"os\.getenv\(['\"]([^'\"]+)['\"]\)",
                  r"process\.env\.([A-Z0-9_]+)",
                  r"System\.getenv\(['\"]([^'\"]+)['\"]\)",
                  r"\${([^}]+)}",
                  r"export\s+([A-Z0-9_]+)=",
                  r"([A-Z0-9_]+)\s*=\s*['\"]?.*['\"]?"
              ]
              found = set()
              for pat in patterns:
                  for match in re.findall(pat, content):
                      if len(match) < 60:
                          found.add(match.strip())
              return found

          def update_file(repo, branch, filename, content):
              content_b64 = base64.b64encode(content.encode()).decode()
              url = f"{api}/repos/{target}/{repo}/contents/{filename}?ref={branch}"
              r = requests.get(url, headers=headers)
              sha = r.json().get("sha") if r.status_code == 200 else None

              data = {
                  "message": f"Update {filename} [Automated]",
                  "content": content_b64,
                  "branch": branch,
              }
              if sha:
                  data["sha"] = sha

              res = requests.put(url, headers=headers, json=data)
              if res.status_code in (200, 201):
                  logging.info(f"âœ… {repo}:{branch} updated successfully.")
              else:
                  logging.error(f"âŒ {repo}:{branch} failed to update ({res.status_code}).")

          logging.info(f"ðŸš€ Scanning all repos for branch '{target_branch}'...")
          repos = fetch_repos()
          logging.info(f"Found {len(repos)} repositories for {target}.")

          for repo in repos:
              branches = get_branches(repo)
              if target_branch not in branches:
                  logging.warning(f"âš ï¸  Skipping {repo}, branch '{target_branch}' not found.")
                  continue

              files = get_repo_files(repo, target_branch)
              all_envs = set()

              for f in files:
                  if any(f.endswith(ext) for ext in [".py", ".js", ".ts", ".java", ".go", ".env", ".sh", ".yml", ".yaml"]):
                      content = download_file(repo, target_branch, f)
                      all_envs |= find_env_vars(content)

              if not all_envs:
                  logging.info(f"â„¹ï¸ No env vars found in {repo}.")
                  continue

              markdown = f"# Environment Variables Used in {repo}\n\n"
              markdown += f"Scanned branch: `{target_branch}`\n\n"
              markdown += "## Variables Found\n"
              markdown += "\n".join(f"- `{v}`" for v in sorted(all_envs))

              # push report to all branches
              for b in branches:
                  update_file(repo, b, "DEPLOYMENT_DOCUMENT.md", markdown)

          logging.info("âœ… Completed scanning and publishing.")
          EOF